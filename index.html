<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-T">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f5f5f5;
            --text-color: #212121;
            --board-bg: #e0e0e0;
            --grid-line-color: #bdbdbd;
            --button-bg: #2196F3;
            --button-text-color: white;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --accent-color: #FFC107;
            --surface-color: #ffffff;
            --border-radius: 8px;
            --disabled-button-bg: #BDBDBD;
            --disabled-button-text-color: #757575;
            --game-over-bg: rgba(0, 0, 0, 0.75);
            --game-over-text-color: white;
            --next-piece-bg: #eeeeee;
        }

        .dark-mode {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --board-bg: #333333;
            --grid-line-color: #555555;
            --button-bg: #64b5f6;
            --button-text-color: #121212;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --accent-color: #FFCA28;
            --surface-color: #1e1e1e;
            --disabled-button-bg: #424242;
            --disabled-button-text-color: #9E9E9E;
            --next-piece-bg: #2c2c2c;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .game-area {
            position: relative;
        }

        canvas#tetrisCanvas {
            border: 1px solid var(--grid-line-color);
            background-color: var(--board-bg);
            display: block;
            border-radius: var(--border-radius);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 180px;
        }

        .info-panel, .controls-panel, .theme-panel {
            background-color: var(--next-piece-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 6px var(--shadow-color);
            text-align: center;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .info-panel h3, .controls-panel h3, .theme-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: var(--text-color);
        }

        #score, #lines {
            font-size: 1.2em;
            font-weight: 500;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        canvas#nextPieceCanvas {
            display: block;
            margin: 0 auto 10px auto;
            border: 1px solid var(--grid-line-color);
            background-color: var(--board-bg);
            border-radius: 4px;
        }

        .controls-panel button, .theme-panel button {
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        .controls-panel button:last-child, .theme-panel button:last-child {
            margin-bottom: 0;
        }

        .controls-panel button:hover, .theme-panel button:hover {
            filter: brightness(1.1);
            box-shadow: 0 3px 6px var(--shadow-color);
        }
        .controls-panel button:active, .theme-panel button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px var(--shadow-color);
        }

        .controls-panel button:disabled {
            background-color: var(--disabled-button-bg);
            color: var(--disabled-button-text-color);
            cursor: not-allowed;
            box-shadow: none;
        }
        .controls-panel button .mdi, .theme-panel button .mdi {
            font-size: 1.3em;
        }

        .game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--game-over-bg);
            color: var(--game-over-text-color);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: var(--border-radius);
            z-index: 100;
        }

        .game-over-modal .mdi {
            font-size: 4em;
            margin-bottom: 15px;
        }
        .game-over-modal h2 {
            margin-bottom: 10px;
            font-size: 2em;
        }
        .game-over-modal p {
            margin-bottom: 20px;
            font-size: 1.2em;
        }
        .game-over-modal button {
            background-color: var(--accent-color);
            color: var(--bg-color);
            padding: 12px 25px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .game-over-modal button:hover {
            filter: brightness(1.1);
        }

        .confetti-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            opacity: 0;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .sidebar {
                width: 100%;
                max-width: 300px;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
            }
            .info-panel, .controls-panel, .theme-panel {
                flex-basis: calc(50% - 10px);
                min-width: 150px;
            }
            .theme-panel {
                flex-basis: 100%;
            }
        }
         @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            .game-container {
                padding: 10px;
            }
             .sidebar {
                flex-direction: column;
                align-items: center;
            }
            .info-panel, .controls-panel, .theme-panel {
                flex-basis: 100%;
                width: 100%;
            }
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <canvas id="tetrisCanvas"></canvas>
            <div id="gameOverModal" class="game-over-modal">
                <span id="gameOverIcon" class="mdi"></span>
                <h2 id="gameOverTitle">Game Over!</h2>
                <p id="gameOverStatus">Status:</p>
                <button id="playAgainButton"><span class="mdi mdi-refresh"></span>Restart</button>
            </div>
        </div>
        <div class="sidebar">
            <div class="info-panel">
                <h3>Score</h3>
                <p id="score">0</p>
                <h3>Mistakes</h3>
                <p id="lines">0</p>
            </div>
            <div class="info-panel">
                <h3>Next</h3>
                <canvas id="nextPieceCanvas"></canvas>
            </div>
            <div class="controls-panel">
                <h3>Controll</h3>
                <button id="startButton"><span class="mdi mdi-play"></span> Start</button>
                <button id="pauseButton" disabled><span class="mdi mdi-pause"></span> Pause</button>
                <button id="restartButton"><span class="mdi mdi-refresh"></span> Restart</button>
            </div>
            <div class="theme-panel">
                <h3>Theme</h3>
                <button id="themeToggleButton"><span class="mdi mdi-brightness-6"></span> Change</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tetrisCanvas');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextPieceCanvas');
        const nextContext = nextCanvas.getContext('2d');

        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const restartButton = document.getElementById('restartButton');
        const themeToggleButton = document.getElementById('themeToggleButton');

        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverIcon = document.getElementById('gameOverIcon');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverStatus = document.getElementById('gameOverStatus');
        const playAgainButton = document.getElementById('playAgainButton');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const NEXT_COLS = 4;
        const NEXT_ROWS = 4;
        const NEXT_BLOCK_SIZE = 20;

        const TETROMINOES = {
            'I': { shape: [[1, 1, 1, 1]], color: '#00BCD4' },
            'J': { shape: [[1, 0, 0], [1, 1, 1]], color: '#2196F3' },
            'L': { shape: [[0, 0, 1], [1, 1, 1]], color: '#FF9800' },
            'O': { shape: [[1, 1], [1, 1]], color: '#FFEB3B' },
            'S': { shape: [[0, 1, 1], [1, 1, 0]], color: '#4CAF50' },
            'T': { shape: [[0, 1, 0], [1, 1, 1]], color: '#9C27B0' },
            'Z': { shape: [[1, 1, 0], [0, 1, 1]], color: '#F44336' }
        };
        const TETROMINO_KEYS = Object.keys(TETROMINOES);
        const WIN_LINES_COUNT = 20;

        let board = [];
        let currentPiece;
        let nextPiece;
        let score = 0;
        let linesCleared = 0;
        let isPlaying = false;
        let isPaused = false;
        let gameOver = false;
        let animationFrameId;
        let lastTime = 0;
        let dropCounter = 0;
        let dropInterval = 1000;

        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        nextCanvas.width = NEXT_COLS * NEXT_BLOCK_SIZE;
        nextCanvas.height = NEXT_ROWS * NEXT_BLOCK_SIZE;

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function createPiece(type) {
            const pieceData = TETROMINOES[type];
            return {
                shape: pieceData.shape.map(row => row.slice()),
                color: pieceData.color,
                x: Math.floor(COLS / 2) - Math.floor(pieceData.shape[0].length / 2),
                y: 0
            };
        }

        function getRandomPiece() {
            const type = TETROMINO_KEYS[Math.floor(Math.random() * TETROMINO_KEYS.length)];
            return createPiece(type);
        }

        function rotate(piece) {
            const newShape = [];
            for (let y = 0; y < piece.shape[0].length; y++) {
                newShape[y] = [];
                for (let x = 0; x < piece.shape.length; x++) {
                    newShape[y][x] = piece.shape[piece.shape.length - 1 - x][y];
                }
            }
            const originalX = piece.x;
            const originalY = piece.y;
            const originalShape = piece.shape;

            piece.shape = newShape;
            if (checkCollision(piece, board)) {
                piece.shape = originalShape;
            }
        }
        
        function checkCollision(piece, gameBoard) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x] !== 0) {
                        let newX = piece.x + x;
                        let newY = piece.y + y;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && gameBoard[newY] && gameBoard[newY][newX] !== 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function mergePiece(piece, gameBoard) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if (piece.y + y >=0) {
                           gameBoard[piece.y + y][piece.x + x] = piece.color;
                        }
                    }
                });
            });
        }

        function pieceDrop() {
            if (isPaused || gameOver) return;
            currentPiece.y++;
            if (checkCollision(currentPiece, board)) {
                currentPiece.y--;
                mergePiece(currentPiece, board);
                clearLines();
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece();
                if (checkCollision(currentPiece, board)) {
                    triggerGameOver(false);
                }
            }
            dropCounter = 0;
        }

        function clearLines() {
            let linesRemoved = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const removedRow = board.splice(y, 1)[0].fill(0);
                board.unshift(removedRow);
                linesRemoved++;
                y++;
            }

            if (linesRemoved > 0) {
                linesCleared += linesRemoved;
                score += linesRemoved * 100 * linesRemoved;
                updateScoreDisplay();

                if (dropInterval > 200) {
                    dropInterval -= linesRemoved * 10;
                }

                if (linesCleared >= WIN_LINES_COUNT && !gameOver) {
                    triggerGameOver(true);
                }
            }
        }
        
        function updateScoreDisplay() {
            scoreElement.textContent = score;
            linesElement.textContent = linesCleared;
        }

        function drawBlock(ctx, x, y, color, blockSize = BLOCK_SIZE, isBoard = true) {
            ctx.fillStyle = color;
            ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            
            if (isBoard) {
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line-color').trim();
                ctx.lineWidth = 0.5;
                const darkerColor = shadeColor(color, -0.2);
                ctx.fillStyle = darkerColor;
                ctx.fillRect((x * blockSize) + blockSize - 2, y * blockSize, 2, blockSize);
                ctx.fillRect(x * blockSize, (y * blockSize) + blockSize - 2, blockSize, 2);
                
                const lighterColor = shadeColor(color, 0.1);
                ctx.fillStyle = lighterColor;
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, 2);
                ctx.fillRect(x * blockSize, y * blockSize, 2, blockSize);
            } else {
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line-color').trim();
                ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
            }
        }

        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (1 + percent));
            G = parseInt(G * (1 + percent));
            B = parseInt(B * (1 + percent));

            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  

            R = (R>0)?R:0;
            G = (G>0)?G:0;
            B = (B>0)?B:0;

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return "#"+RR+GG+BB;
        }


        function drawBoard() {
            context.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-line-color').trim();
            context.lineWidth = 0.5;
            for (let x = 0; x <= COLS; x++) {
                context.beginPath();
                context.moveTo(x * BLOCK_SIZE, 0);
                context.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                context.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                context.beginPath();
                context.moveTo(0, y * BLOCK_SIZE);
                context.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
                context.stroke();
            }

            board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color !== 0) {
                        drawBlock(context, x, y, color);
                    }
                });
            });
        }

        function drawPiece(piece, ctx = context, bSize = BLOCK_SIZE, isBoardPiece = true) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, piece.x + x, piece.y + y, piece.color, bSize, isBoardPiece);
                    }
                });
            });
        }

        function drawNextPiece() {
            nextContext.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-bg').trim();
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                const pieceWidth = nextPiece.shape[0].length * NEXT_BLOCK_SIZE;
                const pieceHeight = nextPiece.shape.length * NEXT_BLOCK_SIZE;
                const offsetX = Math.floor((nextCanvas.width - pieceWidth) / 2 / NEXT_BLOCK_SIZE);
                const offsetY = Math.floor((nextCanvas.height - pieceHeight) / 2 / NEXT_BLOCK_SIZE);

                const tempPiece = { ...nextPiece, x: offsetX, y: offsetY };
                drawPiece(tempPiece, nextContext, NEXT_BLOCK_SIZE, false);
            }
        }
        
        let particles = [];
        const NUM_PARTICLES = 100;

        function createParticles() {
            particles = [];
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.7) * 15 - 5,
                    size: Math.random() * 8 + 4,
                    color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    life: 100
                });
            }
        }

        function drawParticles() {
            particles.forEach((p, index) => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;

                if (p.life <= 0 || p.y > canvas.height || p.x < 0 || p.x > canvas.width) {
                    particles.splice(index, 1);
                } else {
                    context.fillStyle = p.color;
                    context.globalAlpha = p.life / 100;
                    context.fillRect(p.x, p.y, p.size, p.size);
                    context.globalAlpha = 1.0;
                }
            });
        }

        function gameLoop(currentTime = 0) {
            if (gameOver) {
                if (particles.length > 0) {
                    drawBoard();
                    drawParticles();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
                return;
            }
            if (isPaused) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                pieceDrop();
            }

            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function draw() {
            drawBoard();
            if (currentPiece) {
                drawPiece(currentPiece);
            }
            if (particles.length > 0) {
                drawParticles();
            }
        }

        function startGame() {
            board = createBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            score = 0;
            linesCleared = 0;
            dropInterval = 1000;
            gameOver = false;
            isPaused = false;
            isPlaying = true;
            
            updateScoreDisplay();
            drawNextPiece();
            
            startButton.innerHTML = '<span class="mdi mdi-stop"></span> Dayan';
            pauseButton.disabled = false;
            pauseButton.innerHTML = '<span class="mdi mdi-pause"></span> Fasilə';
            restartButton.disabled = false;
            gameOverModal.style.display = 'none';
            particles = [];

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            dropCounter = 0;
            gameLoop();
        }

        function triggerGameOver(isWin) {
            gameOver = true;
            isPlaying = false;
            isPaused = false;
            cancelAnimationFrame(animationFrameId);

            gameOverModal.style.display = 'flex';
            if (isWin) {
                gameOverIcon.className = 'mdi mdi-party-popper';
                gameOverTitle.textContent = 'Təbriklər, Qalib Oldunuz!';
                gameOverStatus.textContent = `Hesab: ${score}, Xətlər: ${linesCleared}`;
                createParticles();
                gameLoop();
            } else {
                gameOverIcon.className = 'mdi mdi-emoticon-sad-outline';
                gameOverTitle.textContent = 'Oyun Bitdi!';
                gameOverStatus.textContent = `Hesab: ${score}, Xətlər: ${linesCleared}`;
            }
            startButton.innerHTML = '<span class="mdi mdi-play"></span> Başla';
            pauseButton.disabled = true;
        }

        document.addEventListener('keydown', event => {
            if (!isPlaying || isPaused || gameOver) return;

            if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') {
                currentPiece.x--;
                if (checkCollision(currentPiece, board)) currentPiece.x++;
            } else if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') {
                currentPiece.x++;
                if (checkCollision(currentPiece, board)) currentPiece.x--;
            } else if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') {
                pieceDrop();
            } else if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') {
                rotate(currentPiece);
            }
            draw();
        });

        startButton.addEventListener('click', () => {
            if (gameOver || !isPlaying) {
                startGame();
            } else {
                triggerGameOver(false);
                startButton.innerHTML = '<span class="mdi mdi-play"></span> Başla';
                pauseButton.disabled = true;
            }
        });

        pauseButton.addEventListener('click', () => {
            if (!isPlaying || gameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.innerHTML = '<span class="mdi mdi-play"></span> Davam Et';
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
            } else {
                pauseButton.innerHTML = '<span class="mdi mdi-pause"></span> Fasilə';
                lastTime = performance.now();
                gameLoop();
            }
        });

        restartButton.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            startGame();
        });
        
        playAgainButton.addEventListener('click', () => {
            gameOverModal.style.display = 'none';
            startGame();
        });

        themeToggleButton.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            if(isPlaying || gameOver){
                 drawBoard();
                 if(currentPiece && !gameOver) drawPiece(currentPiece);
                 drawNextPiece();
                 if(gameOver && particles.length > 0) drawParticles();
            } else {
                drawBoard();
                drawNextPiece();
            }
        });

        function init() {
            board = createBoard();
            drawBoard();
            drawNextPiece();
            updateScoreDisplay();
            pauseButton.disabled = true;
            restartButton.disabled = true;
        }

        init();

    </script>
</body>
</html>
